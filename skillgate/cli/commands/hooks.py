"""Git hooks installer for SkillGate pre-commit integration."""

from __future__ import annotations

import stat
import subprocess
from pathlib import Path

import typer
from rich.console import Console

console = Console()

HOOK_SCRIPT = """\
#!/usr/bin/env sh
# SkillGate pre-commit hook â€” auto-generated by `skillgate hooks install`
# Scans staged skill bundles before allowing commit.

set -e

SKILL_DIRS=""

# Detect skill bundles by manifest files in staged changes
for manifest in SKILL.md skill.json; do
    STAGED=$(git diff --cached --name-only \
        --diff-filter=ACMR -- "*/$manifest" "$manifest" 2>/dev/null || true)
    for f in $STAGED; do
        dir=$(dirname "$f")
        case " $SKILL_DIRS " in
            *" $dir "*) ;;  # already tracked
            *) SKILL_DIRS="$SKILL_DIRS $dir" ;;
        esac
    done
done

# Also scan directories containing staged .py/.js/.ts/.sh files that have a manifest
for ext in py js ts sh; do
    STAGED=$(git diff --cached --name-only --diff-filter=ACMR -- "*.$ext" 2>/dev/null || true)
    for f in $STAGED; do
        dir=$(dirname "$f")
        if [ -f "$dir/SKILL.md" ] || [ -f "$dir/skill.json" ]; then
            case " $SKILL_DIRS " in
                *" $dir "*) ;;
                *) SKILL_DIRS="$SKILL_DIRS $dir" ;;
            esac
        fi
    done
done

if [ -z "$SKILL_DIRS" ]; then
    exit 0  # No skill bundles in staged changes
fi

echo "[skillgate] Scanning staged skill bundles..."
FAILED=0
for dir in $SKILL_DIRS; do
    if ! skillgate scan "$dir" --mode pre-commit --quiet; then
        FAILED=1
    fi
done

if [ "$FAILED" -ne 0 ]; then
    echo "[skillgate] Pre-commit scan failed. Commit blocked."
    echo "[skillgate] Run 'skillgate scan <path> --mode pre-commit' for details."
    exit 1
fi
"""


def install_command(
    force: bool = typer.Option(False, "--force", "-f", help="Overwrite existing hook"),
    path: str | None = typer.Option(
        None, "--path", "-p", help="Git repo path (default: current directory)"
    ),
) -> None:
    """Install SkillGate as a git pre-commit hook."""
    repo_root = Path(path) if path else _find_git_root()
    if repo_root is None:
        console.print("[red]Error:[/red] Not inside a git repository.")
        raise typer.Exit(code=1)

    hooks_dir = repo_root / ".git" / "hooks"
    if not hooks_dir.exists():
        console.print(f"[red]Error:[/red] Git hooks directory not found at {hooks_dir}")
        raise typer.Exit(code=1)

    hook_path = hooks_dir / "pre-commit"

    if hook_path.exists() and not force:
        console.print(
            f"[yellow]Warning:[/yellow] {hook_path} already exists. Use --force to overwrite."
        )
        raise typer.Exit(code=1)

    hook_path.write_text(HOOK_SCRIPT)
    hook_path.chmod(hook_path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    console.print(f"[green]Installed[/green] pre-commit hook at {hook_path}")


def uninstall_command(
    path: str | None = typer.Option(
        None, "--path", "-p", help="Git repo path (default: current directory)"
    ),
) -> None:
    """Remove SkillGate pre-commit hook."""
    repo_root = Path(path) if path else _find_git_root()
    if repo_root is None:
        console.print("[red]Error:[/red] Not inside a git repository.")
        raise typer.Exit(code=1)

    hook_path = repo_root / ".git" / "hooks" / "pre-commit"
    if not hook_path.exists():
        console.print("[yellow]No pre-commit hook found.[/yellow]")
        return

    content = hook_path.read_text()
    if "skillgate" not in content.lower():
        console.print(
            "[yellow]Warning:[/yellow] Existing hook was not installed by SkillGate. "
            "Skipping removal."
        )
        raise typer.Exit(code=1)

    hook_path.unlink()
    console.print("[green]Removed[/green] SkillGate pre-commit hook.")


def _find_git_root() -> Path | None:
    """Find the nearest git repository root."""
    try:
        result = subprocess.run(
            ["git", "rev-parse", "--show-toplevel"],
            capture_output=True,
            text=True,
            timeout=5,
        )
        if result.returncode == 0:
            return Path(result.stdout.strip())
    except (subprocess.TimeoutExpired, FileNotFoundError):
        pass
    return None
